/*
A set of tools for generating node packages, such as to be imported by
default.nix files generated by nixfromnpm.
*/

{
  # Base set of packages, i.e. nixpkgs.
  pkgs,
  # Version of nodejs.
  nodejsVersion ? "4.1"
}:

let
  # Function to replace dots with something
  replaceDots = c: replaceChars ["."] [c];
  inherit (builtins) readDir;
  inherit (pkgs.lib) attrNames attrValues filterAttrs flip foldl
                     hasSuffix hasPrefix removeSuffix replaceChars
                     optional;
in

rec {
  inherit pkgs;

  nodejs = pkgs."nodejs-${replaceDots "_" nodejsVersion}" or (
    throw "The given nodejs version ${nodejsVersion} has not been defined."
  );
  buildNodePackage = import ../buildNodePackage {
    inherit pkgs nodejs;
  };
  # A generic package that will fail to build. This is used to indicate
  # packages that are broken, without failing the entire generation of
  # a package expression.
  brokenPackage = {name, reason}:
    let
     deriv = pkgs.stdenv.mkDerivation {
        name = "broken-${name}";
        buildCommand = ''
          echo "Package ${name} is broken: ${reason}"
          exit 1
        '';
        passthru.withoutTests = deriv;
        passthru.pkgName = name;
        passthru.version = "BROKEN";
      };
    in
    deriv;

  # Concatenate a list of sets.
  joinSets = foldl (a: b: a // b) {};

  # Discover all of the node packages in a folder and turn them into a set
  # mapping `<name>_<version>` to the expression to build that package.
  discoverPackages = {callPackage, rootPath}: let
    # List a directory after filtering the files.
    lsFilter = pred: dir: attrNames (filterAttrs pred (readDir dir));
    # Checks the name and type of a listing to grab non-dotfile dirs.
    isRegDir = name: type: type == "directory" && !(hasPrefix "." name);
    # Names of NPM packages defined in this directory.
    nodeDirs = lsFilter isRegDir (/. + rootPath);
    # Generate the package expression from a package name and .nix path.
    toPackage = name: filepath: let
      versionRaw = removeSuffix ".nix" filepath; # Raw version, i.e. "1.2.4"
      # Join with package name to make the variable name.
      varName = "${replaceDots "-" name}_${replaceDots "-" versionRaw}";
      in
      # Return the singleton set which maps that name to the actual expression.
      {"${varName}" = callPackage (/. + rootPath + "/${name}/${filepath}") {};};
    in
    # For each directory, and each .nix file in it, create a package from that.
    joinSets (flip map nodeDirs (pkgName: let
      pkgDir = /. + rootPath + "/${pkgName}";
      # List of .nix files
      versionFiles = lsFilter (name: type: type == "regular" &&
                               hasSuffix ".nix" name)
                               pkgDir;
      # Check if there is a `latest.nix` file
      hasLatest = lsFilter (n: _: n == "latest.nix") pkgDir != [];
      in
      joinSets (
        map (toPackage pkgName) versionFiles ++
        optional hasLatest {
          "${pkgName}" = callPackage
                           (/. + rootPath + "/${pkgName}/latest.nix") {};
        })));


  # The function that a default.nix can call into which will scan its
  # directory for all of the package files and generate a big attribute set
  # for all of them. Re-exports the `callPackage` function and all of the
  # attribute sets.
  generatePackages = {rootPath, extensions ? {}}:
    let
      callPackage = pkgs.lib.callPackageWith {
        inherit pkgs nodePackages buildNodePackage brokenPackage;
      };
      joinedExtensions = joinSets (attrValues extensions);
      nodePackages = joinSets (attrValues extensions) //
                     discoverPackages {inherit callPackage rootPath;};
    in
    nodePackages // {inherit callPackage;};
}
